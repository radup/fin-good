"""
Advanced malware scanning service for FinGood platform.
Implements multiple scanning engines and detection methods for comprehensive security.
"""

import subprocess
import tempfile
import os
import hashlib
import time
import asyncio
import logging
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass
from enum import Enum
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    yara = None
import requests
from datetime import datetime, timedelta
import math

from app.core.config import settings
from app.core.audit_logger import security_audit_logger

logger = logging.getLogger(__name__)


class ScanEngine(Enum):
    """Available scanning engines"""
    CLAMAV = "clamav"
    YARA = "yara"
    SIGNATURE = "signature"
    BEHAVIORAL = "behavioral"
    VIRUSTOTAL = "virustotal"


class ThreatType(Enum):
    """Types of threats detected"""
    VIRUS = "virus"
    TROJAN = "trojan"
    MALWARE = "malware"
    SUSPICIOUS = "suspicious"
    SCRIPT = "script"
    EXECUTABLE = "executable"
    POLYGLOT = "polyglot"
    ENCRYPTED = "encrypted"


@dataclass
class ScanResult:
    """Result of malware scan"""
    is_clean: bool
    engine: ScanEngine
    threat_detected: bool
    threat_type: Optional[ThreatType] = None
    threat_name: Optional[str] = None
    confidence_score: float = 0.0
    scan_duration: float = 0.0
    details: Dict[str, Any] = None
    error: Optional[str] = None


@dataclass
class ComprehensiveScanResult:
    """Combined result from multiple scanning engines"""
    is_clean: bool
    total_engines: int
    engines_clean: int
    threats_detected: List[ScanResult]
    highest_confidence: float
    scan_duration: float
    metadata: Dict[str, Any]


class MalwareScanner:
    """
    Comprehensive malware scanning service using multiple detection methods.
    """
    
    # Known malicious file hashes (examples - in production, use threat intelligence feeds)
    MALICIOUS_HASHES = {
        # These would be populated from threat intelligence feeds
        'md5': set(),
        'sha1': set(),
        'sha256': set()
    }
    
    # Suspicious file extensions that require additional scrutiny
    HIGH_RISK_EXTENSIONS = {
        '.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs', '.js',
        '.jar', '.php', '.asp', '.jsp', '.py', '.pl', '.rb', '.sh'
    }
    
    # YARA rules for detecting suspicious patterns
    YARA_RULES = """
    rule SuspiciousScripts {
        meta:
            description = "Detects suspicious script patterns"
            severity = "medium"
        strings:
            $script1 = "eval(" nocase
            $script2 = "exec(" nocase
            $script3 = "system(" nocase
            $script4 = "shell_exec(" nocase
            $script5 = "passthru(" nocase
            $script6 = "<?php" nocase
            $script7 = "<script" nocase
            $shell1 = "#!/bin/sh"
            $shell2 = "#!/bin/bash"
        condition:
            any of them
    }
    
    rule EmbeddedExecutable {
        meta:
            description = "Detects embedded executable content"
            severity = "high"
        strings:
            $pe = { 4D 5A }  // PE header
            $elf = { 7F 45 4C 46 }  // ELF header
        condition:
            any of them
    }
    
    rule SuspiciousBase64 {
        meta:
            description = "Detects suspicious Base64 encoded content"
            severity = "medium"
        strings:
            $b64_1 = /[A-Za-z0-9+\/]{100,}={0,2}/ // Long Base64 strings
        condition:
            #b64_1 > 5  // Multiple long Base64 strings
    }
    
    rule MacroMalware {
        meta:
            description = "Detects potential macro malware"
            severity = "high"
        strings:
            $auto1 = "Auto_Open" nocase
            $auto2 = "AutoOpen" nocase
            $auto3 = "Auto_Exec" nocase
            $auto4 = "AutoExec" nocase
            $shell = "Shell" nocase
            $createobject = "CreateObject" nocase
        condition:
            any of ($auto*) and ($shell or $createobject)
    }
    """
    
    def __init__(self):
        self.clamav_available = self._check_clamav_availability()
        self.yara_available = self._initialize_yara()
        self.virustotal_api_key = getattr(settings, 'VIRUSTOTAL_API_KEY', None)
        
        # Create temporary scan directory
        self.temp_dir = Path(tempfile.gettempdir()) / "fingood_scans"
        self.temp_dir.mkdir(exist_ok=True)
        
        logger.info(f"Malware scanner initialized - ClamAV: {self.clamav_available}, YARA: {self.yara_available}")
    
    async def comprehensive_scan(
        self, 
        file_content: bytes, 
        filename: str,
        user_id: Optional[str] = None
    ) -> ComprehensiveScanResult:
        """
        Perform comprehensive malware scan using multiple engines.
        
        Args:
            file_content: Raw file content
            filename: Original filename
            user_id: User ID for audit logging
            
        Returns:
            ComprehensiveScanResult with detailed scan information
        """
        start_time = time.time()
        scan_results = []
        
        try:
            # Calculate file hashes for lookup
            file_hashes = {
                'md5': hashlib.md5(file_content).hexdigest(),
                'sha1': hashlib.sha1(file_content).hexdigest(),
                'sha256': hashlib.sha256(file_content).hexdigest()
            }
            
            # 1. Hash-based detection (fastest)
            hash_result = await self._scan_known_hashes(file_hashes, filename)
            scan_results.append(hash_result)
            
            # If known malicious hash, skip other scans
            if hash_result.threat_detected:
                logger.warning(f"Known malicious hash detected: {filename}")
                security_audit_logger.log_malware_detected(
                    user_id=user_id,
                    filename=filename,
                    malware_type="known_hash",
                    signature=hash_result.threat_name
                )
            
            # 2. Signature-based detection
            signature_result = await self._scan_signatures(file_content, filename)
            scan_results.append(signature_result)
            
            # 3. YARA rules scan
            if self.yara_available:
                yara_result = await self._scan_yara(file_content, filename)
                scan_results.append(yara_result)
            
            # 4. ClamAV scan (if available)
            if self.clamav_available:
                clamav_result = await self._scan_clamav(file_content, filename)
                scan_results.append(clamav_result)
            
            # 5. Behavioral analysis
            behavioral_result = await self._scan_behavioral(file_content, filename)
            scan_results.append(behavioral_result)
            
            # 6. VirusTotal scan (if API key available and file is suspicious)
            if self.virustotal_api_key and any(r.threat_detected for r in scan_results):
                vt_result = await self._scan_virustotal(file_hashes, filename)
                if vt_result:
                    scan_results.append(vt_result)
            
            # Analyze results
            threats_detected = [r for r in scan_results if r.threat_detected]
            engines_clean = len([r for r in scan_results if not r.threat_detected and not r.error])
            highest_confidence = max([r.confidence_score for r in threats_detected], default=0.0)
            
            # Determine overall result
            is_clean = len(threats_detected) == 0
            
            scan_duration = time.time() - start_time
            
            result = ComprehensiveScanResult(
                is_clean=is_clean,
                total_engines=len(scan_results),
                engines_clean=engines_clean,
                threats_detected=threats_detected,
                highest_confidence=highest_confidence,
                scan_duration=scan_duration,
                metadata={
                    'file_hashes': file_hashes,
                    'filename': filename,
                    'file_size': len(file_content),
                    'scan_timestamp': datetime.utcnow().isoformat()
                }
            )
            
            # Log scan results
            if not is_clean:
                security_audit_logger.log_malware_detected(
                    user_id=user_id,
                    filename=filename,
                    malware_type=threats_detected[0].threat_type.value if threats_detected else "unknown",
                    signature=threats_detected[0].threat_name or "unknown"
                )
            
            return result
            
        except Exception as e:
            logger.error(f"Comprehensive scan failed for {filename}: {e}")
            return ComprehensiveScanResult(
                is_clean=False,
                total_engines=0,
                engines_clean=0,
                threats_detected=[],
                highest_confidence=0.0,
                scan_duration=time.time() - start_time,
                metadata={'error': str(e)}
            )
    
    async def _scan_known_hashes(
        self, 
        file_hashes: Dict[str, str], 
        filename: str
    ) -> ScanResult:
        """Scan against known malicious hashes"""
        start_time = time.time()
        
        for hash_type, hash_value in file_hashes.items():
            if hash_value in self.MALICIOUS_HASHES.get(hash_type, set()):
                return ScanResult(
                    is_clean=False,
                    engine=ScanEngine.SIGNATURE,
                    threat_detected=True,
                    threat_type=ThreatType.MALWARE,
                    threat_name=f"Known malicious {hash_type}: {hash_value}",
                    confidence_score=1.0,
                    scan_duration=time.time() - start_time,
                    details={'hash_type': hash_type, 'hash_value': hash_value}
                )
        
        return ScanResult(
            is_clean=True,
            engine=ScanEngine.SIGNATURE,
            threat_detected=False,
            confidence_score=0.0,
            scan_duration=time.time() - start_time,
            details={'hashes_checked': list(file_hashes.keys())}
        )
    
    async def _scan_signatures(self, file_content: bytes, filename: str) -> ScanResult:
        """Scan for suspicious signatures and patterns"""
        start_time = time.time()
        
        # Check file extension
        file_ext = Path(filename).suffix.lower()
        if file_ext in self.HIGH_RISK_EXTENSIONS:
            return ScanResult(
                is_clean=False,
                engine=ScanEngine.SIGNATURE,
                threat_detected=True,
                threat_type=ThreatType.SUSPICIOUS,
                threat_name=f"High-risk file extension: {file_ext}",
                confidence_score=0.7,
                scan_duration=time.time() - start_time,
                details={'extension': file_ext}
            )
        
        # Check for embedded executables in non-executable files
        if file_ext in ['.csv', '.txt', '.xml']:
            # Look for PE headers
            if b'MZ' in file_content[:1024] or b'\x7fELF' in file_content[:1024]:
                return ScanResult(
                    is_clean=False,
                    engine=ScanEngine.SIGNATURE,
                    threat_detected=True,
                    threat_type=ThreatType.EXECUTABLE,
                    threat_name="Embedded executable in text file",
                    confidence_score=0.9,
                    scan_duration=time.time() - start_time,
                    details={'type': 'embedded_executable'}
                )
        
        # Check for script injections
        script_patterns = [
            b'<script',
            b'javascript:',
            b'vbscript:',
            b'<?php',
            b'<%@',
            b'eval(',
            b'exec(',
            b'system(',
        ]
        
        for pattern in script_patterns:
            if pattern in file_content.lower():
                return ScanResult(
                    is_clean=False,
                    engine=ScanEngine.SIGNATURE,
                    threat_detected=True,
                    threat_type=ThreatType.SCRIPT,
                    threat_name=f"Script injection pattern: {pattern.decode('utf-8', errors='ignore')}",
                    confidence_score=0.8,
                    scan_duration=time.time() - start_time,
                    details={'pattern': pattern.decode('utf-8', errors='ignore')}
                )
        
        return ScanResult(
            is_clean=True,
            engine=ScanEngine.SIGNATURE,
            threat_detected=False,
            confidence_score=0.0,
            scan_duration=time.time() - start_time,
            details={'patterns_checked': len(script_patterns)}
        )
    
    async def _scan_yara(self, file_content: bytes, filename: str) -> ScanResult:
        """Scan using YARA rules"""
        if not self.yara_available:
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.YARA,
                threat_detected=False,
                error="YARA not available"
            )
        
        start_time = time.time()
        
        try:
            matches = self.yara_rules.match(data=file_content)
            
            if matches:
                # Get the highest severity match
                highest_severity = max(
                    [m.meta.get('severity', 'low') for m in matches],
                    key=lambda x: {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}.get(x, 1)
                )
                
                confidence_map = {'low': 0.3, 'medium': 0.6, 'high': 0.8, 'critical': 0.95}
                
                return ScanResult(
                    is_clean=False,
                    engine=ScanEngine.YARA,
                    threat_detected=True,
                    threat_type=ThreatType.SUSPICIOUS,
                    threat_name=f"YARA rule match: {matches[0].rule}",
                    confidence_score=confidence_map.get(highest_severity, 0.5),
                    scan_duration=time.time() - start_time,
                    details={
                        'rules_matched': [m.rule for m in matches],
                        'highest_severity': highest_severity
                    }
                )
            
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.YARA,
                threat_detected=False,
                confidence_score=0.0,
                scan_duration=time.time() - start_time,
                details={'rules_checked': True}
            )
            
        except Exception as e:
            logger.error(f"YARA scan failed: {e}")
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.YARA,
                threat_detected=False,
                error=str(e),
                scan_duration=time.time() - start_time
            )
    
    async def _scan_clamav(self, file_content: bytes, filename: str) -> ScanResult:
        """Scan using ClamAV"""
        if not self.clamav_available:
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.CLAMAV,
                threat_detected=False,
                error="ClamAV not available"
            )
        
        start_time = time.time()
        
        # Create temporary file
        temp_file = self.temp_dir / f"scan_{int(time.time())}_{hashlib.md5(filename.encode()).hexdigest()[:8]}"
        
        try:
            # Write content to temporary file
            with open(temp_file, 'wb') as f:
                f.write(file_content)
            
            # Run ClamAV scan
            result = subprocess.run(
                ['clamscan', '--no-summary', str(temp_file)],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Parse results
            if result.returncode == 0:
                # Clean file
                return ScanResult(
                    is_clean=True,
                    engine=ScanEngine.CLAMAV,
                    threat_detected=False,
                    confidence_score=0.0,
                    scan_duration=time.time() - start_time,
                    details={'clamav_output': result.stdout}
                )
            elif result.returncode == 1:
                # Malware detected
                output_lines = result.stdout.strip().split('\n')
                threat_line = next((line for line in output_lines if 'FOUND' in line), '')
                threat_name = threat_line.split(':')[-1].strip() if threat_line else 'Unknown'
                
                return ScanResult(
                    is_clean=False,
                    engine=ScanEngine.CLAMAV,
                    threat_detected=True,
                    threat_type=ThreatType.VIRUS,
                    threat_name=threat_name,
                    confidence_score=0.95,
                    scan_duration=time.time() - start_time,
                    details={'clamav_output': result.stdout}
                )
            else:
                # Error occurred
                return ScanResult(
                    is_clean=True,
                    engine=ScanEngine.CLAMAV,
                    threat_detected=False,
                    error=f"ClamAV error: {result.stderr}",
                    scan_duration=time.time() - start_time
                )
                
        except subprocess.TimeoutExpired:
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.CLAMAV,
                threat_detected=False,
                error="ClamAV scan timeout",
                scan_duration=time.time() - start_time
            )
        except Exception as e:
            return ScanResult(
                is_clean=True,
                engine=ScanEngine.CLAMAV,
                threat_detected=False,
                error=str(e),
                scan_duration=time.time() - start_time
            )
        finally:
            # Clean up temporary file
            try:
                temp_file.unlink()
            except:
                pass
    
    async def _scan_behavioral(self, file_content: bytes, filename: str) -> ScanResult:
        """Behavioral analysis of file content"""
        start_time = time.time()
        
        suspicious_indicators = []
        confidence_score = 0.0
        
        # Check file entropy (high entropy may indicate encryption/compression)
        entropy = self._calculate_entropy(file_content)
        if entropy > 7.5:
            suspicious_indicators.append(f"High entropy: {entropy:.2f}")
            confidence_score += 0.2
        
        # Check for multiple file signatures (polyglot)
        signatures_found = 0
        common_signatures = [
            (b'%PDF', 'PDF'),
            (b'PK\x03\x04', 'ZIP'),
            (b'\xff\xd8\xff', 'JPEG'),
            (b'GIF8', 'GIF'),
            (b'MZ', 'PE'),
            (b'\x7fELF', 'ELF')
        ]
        
        for sig, name in common_signatures:
            if sig in file_content:
                signatures_found += 1
        
        if signatures_found > 1:
            suspicious_indicators.append(f"Multiple file signatures detected: {signatures_found}")
            confidence_score += 0.3
        
        # Check for excessive null bytes (may indicate padding/evasion)
        null_ratio = file_content.count(b'\x00') / len(file_content) if file_content else 0
        if null_ratio > 0.1:
            suspicious_indicators.append(f"High null byte ratio: {null_ratio:.2f}")
            confidence_score += 0.1
        
        # Check for suspicious strings in non-executable files
        file_ext = Path(filename).suffix.lower()
        if file_ext in ['.csv', '.txt', '.xml']:
            suspicious_strings = [
                b'cmd.exe', b'powershell', b'rundll32', b'regsvr32',
                b'wscript', b'cscript', b'mshta', b'certutil'
            ]
            
            for sus_str in suspicious_strings:
                if sus_str in file_content.lower():
                    suspicious_indicators.append(f"Suspicious string: {sus_str.decode()}")
                    confidence_score += 0.2
        
        # Determine result
        if suspicious_indicators:
            return ScanResult(
                is_clean=False,
                engine=ScanEngine.BEHAVIORAL,
                threat_detected=True,
                threat_type=ThreatType.SUSPICIOUS,
                threat_name=f"Behavioral analysis: {', '.join(suspicious_indicators[:3])}",
                confidence_score=min(confidence_score, 0.9),
                scan_duration=time.time() - start_time,
                details={'indicators': suspicious_indicators}
            )
        
        return ScanResult(
            is_clean=True,
            engine=ScanEngine.BEHAVIORAL,
            threat_detected=False,
            confidence_score=0.0,
            scan_duration=time.time() - start_time,
            details={'entropy': entropy}
        )
    
    async def _scan_virustotal(
        self, 
        file_hashes: Dict[str, str], 
        filename: str
    ) -> Optional[ScanResult]:
        """Scan using VirusTotal API"""
        if not self.virustotal_api_key:
            return None
        
        start_time = time.time()
        
        try:
            # Use SHA256 for VirusTotal lookup
            sha256_hash = file_hashes['sha256']
            
            headers = {'x-apikey': self.virustotal_api_key}
            url = f"https://www.virustotal.com/api/v3/files/{sha256_hash}"
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                attributes = data.get('data', {}).get('attributes', {})
                stats = attributes.get('last_analysis_stats', {})
                
                malicious = stats.get('malicious', 0)
                total = sum(stats.values())
                
                if malicious > 0:
                    confidence_score = malicious / total if total > 0 else 0.5
                    
                    return ScanResult(
                        is_clean=False,
                        engine=ScanEngine.VIRUSTOTAL,
                        threat_detected=True,
                        threat_type=ThreatType.MALWARE,
                        threat_name=f"VirusTotal detection: {malicious}/{total} engines",
                        confidence_score=confidence_score,
                        scan_duration=time.time() - start_time,
                        details={
                            'stats': stats,
                            'scan_date': attributes.get('last_analysis_date')
                        }
                    )
                else:
                    return ScanResult(
                        is_clean=True,
                        engine=ScanEngine.VIRUSTOTAL,
                        threat_detected=False,
                        confidence_score=0.0,
                        scan_duration=time.time() - start_time,
                        details={'stats': stats}
                    )
            
            elif response.status_code == 404:
                # File not found in VirusTotal database
                return ScanResult(
                    is_clean=True,
                    engine=ScanEngine.VIRUSTOTAL,
                    threat_detected=False,
                    confidence_score=0.0,
                    scan_duration=time.time() - start_time,
                    details={'status': 'not_found'}
                )
            
            else:
                logger.warning(f"VirusTotal API error: {response.status_code}")
                return None
                
        except Exception as e:
            logger.error(f"VirusTotal scan failed: {e}")
            return None
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        
        # Count frequency of each byte value
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate entropy
        entropy = 0
        data_len = len(data)
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    def _check_clamav_availability(self) -> bool:
        """Check if ClamAV is available"""
        try:
            result = subprocess.run(
                ['clamscan', '--version'],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def _initialize_yara(self) -> bool:
        """Initialize YARA rules"""
        try:
            import yara
            self.yara_rules = yara.compile(source=self.YARA_RULES)
            return True
        except ImportError:
            logger.warning("YARA not available - install python-yara for enhanced scanning")
            return False
        except Exception as e:
            logger.error(f"Failed to initialize YARA rules: {e}")
            return False


class MalwareScannerFactory:
    """Factory for creating malware scanner instances"""
    
    _instance = None
    
    @classmethod
    def get_scanner(cls) -> MalwareScanner:
        """Get singleton malware scanner instance"""
        if cls._instance is None:
            cls._instance = MalwareScanner()
        return cls._instance


# Convenience function for quick scans
async def scan_file_for_malware(
    file_content: bytes, 
    filename: str,
    user_id: Optional[str] = None
) -> ComprehensiveScanResult:
    """
    Convenience function to scan a file for malware.
    
    Args:
        file_content: Raw file content
        filename: Original filename
        user_id: User ID for audit logging
        
    Returns:
        ComprehensiveScanResult
    """
    scanner = MalwareScannerFactory.get_scanner()
    return await scanner.comprehensive_scan(file_content, filename, user_id)